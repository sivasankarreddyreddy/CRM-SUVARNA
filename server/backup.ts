import { db } from './db.js';
import fs from 'fs';
import path from 'path';

export async function createDatabaseBackup(): Promise<string> {
  try {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const backupFileName = `backup_${timestamp}.sql`;
    const backupPath = path.join(process.cwd(), 'backups', backupFileName);
    
    // Ensure backups directory exists
    const backupsDir = path.join(process.cwd(), 'backups');
    if (!fs.existsSync(backupsDir)) {
      fs.mkdirSync(backupsDir, { recursive: true });
    }

    // Get all table names
    const tablesResult = await db.execute(`
      SELECT table_name 
      FROM information_schema.tables 
      WHERE table_schema = 'public' 
      AND table_type = 'BASE TABLE'
      ORDER BY table_name
    `);

    let backupContent = `-- Database Backup Created: ${new Date().toISOString()}\n`;
    backupContent += `-- Generated by Healthcare CRM Application\n\n`;

    // Add table creation and data for each table
    for (const tableRow of tablesResult.rows as any[]) {
      const tableName = tableRow.table_name;
      
      // Skip system tables
      if (tableName.startsWith('pg_') || tableName.startsWith('information_schema')) {
        continue;
      }

      try {
        // Get table structure
        const createTableResult = await db.execute(`
          SELECT 
            'CREATE TABLE ' || t.table_schema||'.'||t.table_name||' (' ||
            array_to_string(
              array_agg(
                c.column_name ||' '|| c.data_type ||
                CASE 
                  WHEN c.character_maximum_length IS NOT NULL 
                  THEN '('||c.character_maximum_length||')' 
                  ELSE '' 
                END ||
                CASE WHEN c.is_nullable = 'NO' THEN ' NOT NULL' ELSE '' END
              ), ', '
            ) || ');' as create_statement
          FROM information_schema.tables t
          JOIN information_schema.columns c ON c.table_name = t.table_name AND c.table_schema = t.table_schema
          WHERE t.table_schema = 'public' AND t.table_name = $1
          GROUP BY t.table_schema, t.table_name
        `, [tableName]);

        if (createTableResult.rows.length > 0) {
          backupContent += `-- Table: ${tableName}\n`;
          backupContent += `DROP TABLE IF EXISTS ${tableName} CASCADE;\n`;
          backupContent += `${(createTableResult.rows[0] as any).create_statement}\n\n`;
        }

        // Get table data
        const dataResult = await db.execute(`SELECT * FROM "${tableName}"`);
        
        if (dataResult.rows.length > 0) {
          // Get column names
          const columnsResult = await db.execute(`
            SELECT column_name 
            FROM information_schema.columns 
            WHERE table_name = $1 AND table_schema = 'public'
            ORDER BY ordinal_position
          `, [tableName]);

          const columnNames = (columnsResult.rows as any[]).map(row => row.column_name);
          
          backupContent += `-- Data for table: ${tableName}\n`;
          
          for (const row of dataResult.rows as any[]) {
            const values = columnNames.map(col => {
              const value = row[col];
              if (value === null) return 'NULL';
              if (typeof value === 'string') return `'${value.replace(/'/g, "''")}'`;
              if (value instanceof Date) return `'${value.toISOString()}'`;
              if (typeof value === 'boolean') return value ? 'true' : 'false';
              return value;
            });
            
            backupContent += `INSERT INTO "${tableName}" (${columnNames.map(col => `"${col}"`).join(', ')}) VALUES (${values.join(', ')});\n`;
          }
          backupContent += '\n';
        }
      } catch (error) {
        console.error(`Error backing up table ${tableName}:`, error);
        backupContent += `-- Error backing up table ${tableName}: ${error.message}\n\n`;
      }
    }

    // Write backup to file
    fs.writeFileSync(backupPath, backupContent);
    
    return backupPath;
  } catch (error) {
    console.error('Error creating database backup:', error);
    throw new Error(`Failed to create database backup: ${error.message}`);
  }
}

export async function listBackups(): Promise<string[]> {
  const backupsDir = path.join(process.cwd(), 'backups');
  
  if (!fs.existsSync(backupsDir)) {
    return [];
  }

  const files = fs.readdirSync(backupsDir);
  return files
    .filter(file => file.endsWith('.sql'))
    .sort((a, b) => b.localeCompare(a)); // Sort newest first
}

export async function deleteBackup(filename: string): Promise<boolean> {
  try {
    const backupPath = path.join(process.cwd(), 'backups', filename);
    
    if (fs.existsSync(backupPath)) {
      fs.unlinkSync(backupPath);
      return true;
    }
    return false;
  } catch (error) {
    console.error('Error deleting backup:', error);
    return false;
  }
}