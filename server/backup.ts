import { db } from './db.js';
import fs from 'fs';
import path from 'path';

export async function createDatabaseBackup(): Promise<string> {
  try {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const backupFileName = `backup_${timestamp}.sql`;
    const backupPath = path.join(process.cwd(), 'backups', backupFileName);
    
    // Ensure backups directory exists
    const backupsDir = path.join(process.cwd(), 'backups');
    if (!fs.existsSync(backupsDir)) {
      fs.mkdirSync(backupsDir, { recursive: true });
    }

    // Get database version and connection info
    const dbVersionResult = await db.execute(`SELECT version() as version`);
    const dbVersion = (dbVersionResult.rows[0] as any)?.version || 'Unknown';
    
    let backupContent = `-- =============================================\n`;
    backupContent += `-- HEALTHCARE CRM DATABASE COMPLETE BACKUP\n`;
    backupContent += `-- =============================================\n`;
    backupContent += `-- Backup Created: ${new Date().toISOString()}\n`;
    backupContent += `-- Database Version: ${dbVersion}\n`;
    backupContent += `-- Generated by Healthcare Information Management System\n`;
    backupContent += `-- \n`;
    backupContent += `-- This file contains:\n`;
    backupContent += `-- 1. Complete table schemas (CREATE TABLE statements)\n`;
    backupContent += `-- 2. Primary key constraints\n`;
    backupContent += `-- 3. Foreign key constraints\n`;
    backupContent += `-- 4. Indexes\n`;
    backupContent += `-- 5. All table data (INSERT statements)\n`;
    backupContent += `-- =============================================\n\n`;
    
    backupContent += `-- Disable foreign key checks during restore\n`;
    backupContent += `SET session_replication_role = replica;\n\n`;

    // Define all the tables we want to backup in the correct order
    const tablesToBackup = [
      'teams', 'vendor_groups', 'vendors', 'users', 'contacts', 
      'companies', 'leads', 'opportunities', 'modules', 'products', 
      'product_modules', 'quotations', 'quotation_items', 
      'sales_orders', 'sales_order_items', 'tasks', 'activities', 
      'appointments', 'sales_targets', 'lead_history'
    ];

    for (const tableName of tablesToBackup) {
      try {
        console.log(`Backing up table: ${tableName}`);
        
        // Check if table exists
        const tableExistsResult = await db.execute(`
          SELECT COUNT(*) as count
          FROM information_schema.tables 
          WHERE table_schema = 'public' AND table_name = '${tableName}'
        `);

        const tableExists = (tableExistsResult.rows[0] as any)?.count > 0;
        if (!tableExists) {
          console.log(`Table ${tableName} does not exist, skipping...`);
          continue;
        }

        backupContent += `\n-- =============================================\n`;
        backupContent += `-- Table: ${tableName}\n`;
        backupContent += `-- =============================================\n\n`;

        // Get table schema (CREATE TABLE statement)
        const schemaResult = await db.execute(`
          SELECT 
            'CREATE TABLE "' || t.table_name || '" (' || E'\\n' ||
            string_agg(
              '  "' || c.column_name || '" ' || 
              UPPER(c.data_type) ||
              CASE 
                WHEN c.character_maximum_length IS NOT NULL 
                THEN '(' || c.character_maximum_length || ')' 
                WHEN c.numeric_precision IS NOT NULL AND c.numeric_scale IS NOT NULL
                THEN '(' || c.numeric_precision || ',' || c.numeric_scale || ')'
                WHEN c.numeric_precision IS NOT NULL
                THEN '(' || c.numeric_precision || ')'
                ELSE '' 
              END ||
              CASE WHEN c.is_nullable = 'NO' THEN ' NOT NULL' ELSE '' END ||
              CASE WHEN c.column_default IS NOT NULL THEN ' DEFAULT ' || c.column_default ELSE '' END,
              ',' || E'\\n'
            ) || E'\\n' || ');' as create_statement
          FROM information_schema.tables t
          JOIN information_schema.columns c ON c.table_name = t.table_name AND c.table_schema = t.table_schema
          WHERE t.table_schema = 'public' AND t.table_name = '${tableName}'
          GROUP BY t.table_name
        `);

        if (schemaResult.rows.length > 0) {
          backupContent += `-- Drop table if exists\n`;
          backupContent += `DROP TABLE IF EXISTS "${tableName}" CASCADE;\n\n`;
          backupContent += `-- Create table structure\n`;
          backupContent += `${(schemaResult.rows[0] as any).create_statement}\n\n`;
        }

        // Get primary key constraints
        const pkResult = await db.execute(`
          SELECT 
            'ALTER TABLE "' || tc.table_name || '" ADD CONSTRAINT "' || tc.constraint_name || 
            '" PRIMARY KEY (' || string_agg('"' || kcu.column_name || '"', ', ') || ');' as pk_statement
          FROM information_schema.table_constraints tc
          JOIN information_schema.key_column_usage kcu ON tc.constraint_name = kcu.constraint_name
          WHERE tc.constraint_type = 'PRIMARY KEY' 
          AND tc.table_schema = 'public' 
          AND tc.table_name = '${tableName}'
          GROUP BY tc.table_name, tc.constraint_name
        `);

        if (pkResult.rows.length > 0) {
          backupContent += `-- Primary key constraint\n`;
          backupContent += `${(pkResult.rows[0] as any).pk_statement}\n\n`;
        }

        // Get foreign key constraints
        const fkResult = await db.execute(`
          SELECT 
            'ALTER TABLE "' || tc.table_name || '" ADD CONSTRAINT "' || tc.constraint_name || 
            '" FOREIGN KEY (' || string_agg('"' || kcu.column_name || '"', ', ') || 
            ') REFERENCES "' || ccu.table_name || '" (' || 
            string_agg('"' || ccu.column_name || '"', ', ') || ');' as fk_statement
          FROM information_schema.table_constraints tc
          JOIN information_schema.key_column_usage kcu ON tc.constraint_name = kcu.constraint_name
          JOIN information_schema.constraint_column_usage ccu ON ccu.constraint_name = tc.constraint_name
          WHERE tc.constraint_type = 'FOREIGN KEY' 
          AND tc.table_schema = 'public' 
          AND tc.table_name = '${tableName}'
          GROUP BY tc.table_name, tc.constraint_name, ccu.table_name
        `);

        if (fkResult.rows.length > 0) {
          backupContent += `-- Foreign key constraints\n`;
          for (const fkRow of fkResult.rows as any[]) {
            backupContent += `${fkRow.fk_statement}\n`;
          }
          backupContent += '\n';
        }

        // Get indexes
        const indexResult = await db.execute(`
          SELECT 
            'CREATE ' || 
            CASE WHEN i.indisunique THEN 'UNIQUE ' ELSE '' END ||
            'INDEX "' || c.relname || '" ON "' || t.relname || '" (' ||
            string_agg('"' || a.attname || '"', ', ') || ');' as index_statement
          FROM pg_index i
          JOIN pg_class c ON i.indexrelid = c.oid
          JOIN pg_class t ON i.indrelid = t.oid
          JOIN pg_attribute a ON a.attrelid = t.oid AND a.attnum = ANY(i.indkey)
          WHERE t.relname = '${tableName}'
          AND c.relname NOT LIKE '%_pkey'
          GROUP BY c.relname, t.relname, i.indisunique
        `);

        if (indexResult.rows.length > 0) {
          backupContent += `-- Indexes\n`;
          for (const indexRow of indexResult.rows as any[]) {
            backupContent += `${indexRow.index_statement}\n`;
          }
          backupContent += '\n';
        }

        // Get table data
        const dataResult = await db.execute(`SELECT * FROM "${tableName}"`);
        
        if (dataResult.rows.length > 0) {
          // Get column information
          const columnsResult = await db.execute(`
            SELECT column_name, data_type, is_nullable
            FROM information_schema.columns 
            WHERE table_name = '${tableName}' AND table_schema = 'public'
            ORDER BY ordinal_position
          `);

          const columns = columnsResult.rows as any[];
          const columnNames = columns.map(col => col.column_name);
          
          backupContent += `-- Table data (${dataResult.rows.length} rows)\n`;
          
          // Generate INSERT statements
          for (const row of dataResult.rows as any[]) {
            const values = columnNames.map(col => {
              const value = row[col];
              if (value === null || value === undefined) return 'NULL';
              if (typeof value === 'string') {
                // Escape single quotes and wrap in quotes
                return `'${value.replace(/'/g, "''").replace(/\\/g, '\\\\')}'`;
              }
              if (value instanceof Date) return `'${value.toISOString()}'`;
              if (typeof value === 'boolean') return value ? 'true' : 'false';
              if (typeof value === 'number') return String(value);
              if (Array.isArray(value)) return `'${JSON.stringify(value).replace(/'/g, "''")}'`;
              if (typeof value === 'object') return `'${JSON.stringify(value).replace(/'/g, "''")}'`;
              
              return `'${String(value).replace(/'/g, "''")}'`;
            });
            
            backupContent += `INSERT INTO "${tableName}" (${columnNames.map(col => `"${col}"`).join(', ')}) VALUES (${values.join(', ')});\n`;
          }
          backupContent += '\n';
        } else {
          backupContent += `-- Table ${tableName} is empty (no data to insert)\n\n`;
        }
      } catch (error) {
        console.error(`Error backing up table ${tableName}:`, error);
        const errorMessage = error instanceof Error ? error.message : String(error);
        backupContent += `-- Error backing up table ${tableName}: ${errorMessage}\n\n`;
      }
    }

    // Add footer
    backupContent += `\n-- =============================================\n`;
    backupContent += `-- END OF BACKUP\n`;
    backupContent += `-- =============================================\n`;
    backupContent += `-- Re-enable foreign key checks\n`;
    backupContent += `SET session_replication_role = DEFAULT;\n\n`;
    backupContent += `-- Backup completed successfully\n`;
    backupContent += `-- Total tables backed up: ${tablesToBackup.length}\n`;
    backupContent += `-- Backup created: ${new Date().toISOString()}\n`;

    // Write backup to file
    fs.writeFileSync(backupPath, backupContent);
    
    console.log(`Backup created successfully: ${backupPath}`);
    console.log(`Backup file size: ${fs.statSync(backupPath).size} bytes`);
    
    return backupPath;
  } catch (error) {
    console.error('Error creating database backup:', error);
    const errorMessage = error instanceof Error ? error.message : String(error);
    throw new Error(`Failed to create database backup: ${errorMessage}`);
  }
}

export async function listBackups(): Promise<string[]> {
  const backupsDir = path.join(process.cwd(), 'backups');
  
  if (!fs.existsSync(backupsDir)) {
    return [];
  }

  const files = fs.readdirSync(backupsDir);
  return files
    .filter(file => file.endsWith('.sql'))
    .sort((a, b) => b.localeCompare(a)); // Sort newest first
}

export async function deleteBackup(filename: string): Promise<boolean> {
  try {
    const backupPath = path.join(process.cwd(), 'backups', filename);
    
    if (fs.existsSync(backupPath)) {
      fs.unlinkSync(backupPath);
      return true;
    }
    return false;
  } catch (error) {
    console.error('Error deleting backup:', error);
    return false;
  }
}