import { db } from './db.js';
import fs from 'fs';
import path from 'path';

export async function createDatabaseBackup(): Promise<string> {
  try {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const backupFileName = `backup_${timestamp}.sql`;
    const backupPath = path.join(process.cwd(), 'backups', backupFileName);
    
    // Ensure backups directory exists
    const backupsDir = path.join(process.cwd(), 'backups');
    if (!fs.existsSync(backupsDir)) {
      fs.mkdirSync(backupsDir, { recursive: true });
    }

    let backupContent = `-- Database Backup Created: ${new Date().toISOString()}\n`;
    backupContent += `-- Generated by Healthcare CRM Application\n\n`;

    // Define all the tables we want to backup in the correct order
    const tablesToBackup = [
      'teams', 'vendor_groups', 'vendors', 'users', 'contacts', 
      'companies', 'leads', 'opportunities', 'modules', 'products', 
      'product_modules', 'quotations', 'quotation_items', 
      'sales_orders', 'sales_order_items', 'tasks', 'activities', 
      'appointments', 'sales_targets', 'lead_history'
    ];

    for (const tableName of tablesToBackup) {
      try {
        console.log(`Backing up table: ${tableName}`);
        
        // Check if table exists
        const tableExistsResult = await db.execute(`
          SELECT COUNT(*) as count
          FROM information_schema.tables 
          WHERE table_schema = 'public' AND table_name = '${tableName}'
        `);

        const tableExists = (tableExistsResult.rows[0] as any)?.count > 0;
        if (!tableExists) {
          console.log(`Table ${tableName} does not exist, skipping...`);
          continue;
        }

        // Get table data
        const dataResult = await db.execute(`SELECT * FROM "${tableName}"`);
        
        if (dataResult.rows.length > 0) {
          // Get column information
          const columnsResult = await db.execute(`
            SELECT column_name, data_type, is_nullable
            FROM information_schema.columns 
            WHERE table_name = '${tableName}' AND table_schema = 'public'
            ORDER BY ordinal_position
          `);

          const columns = columnsResult.rows as any[];
          const columnNames = columns.map(col => col.column_name);
          
          backupContent += `-- Data for table: ${tableName}\n`;
          backupContent += `-- Rows: ${dataResult.rows.length}\n`;
          
          // Generate INSERT statements
          for (const row of dataResult.rows as any[]) {
            const values = columnNames.map(col => {
              const value = row[col];
              if (value === null || value === undefined) return 'NULL';
              if (typeof value === 'string') {
                // Escape single quotes and wrap in quotes
                return `'${value.replace(/'/g, "''").replace(/\\/g, '\\\\')}'`;
              }
              if (value instanceof Date) return `'${value.toISOString()}'`;
              if (typeof value === 'boolean') return value ? 'true' : 'false';
              if (typeof value === 'number') return String(value);
              if (Array.isArray(value)) return `'${JSON.stringify(value).replace(/'/g, "''")}'`;
              if (typeof value === 'object') return `'${JSON.stringify(value).replace(/'/g, "''")}'`;
              
              return `'${String(value).replace(/'/g, "''")}'`;
            });
            
            backupContent += `INSERT INTO "${tableName}" (${columnNames.map(col => `"${col}"`).join(', ')}) VALUES (${values.join(', ')});\n`;
          }
          backupContent += '\n';
        } else {
          backupContent += `-- Table ${tableName} is empty\n\n`;
        }
      } catch (error) {
        console.error(`Error backing up table ${tableName}:`, error);
        const errorMessage = error instanceof Error ? error.message : String(error);
        backupContent += `-- Error backing up table ${tableName}: ${errorMessage}\n\n`;
      }
    }

    // Write backup to file
    fs.writeFileSync(backupPath, backupContent);
    
    console.log(`Backup created successfully: ${backupPath}`);
    console.log(`Backup file size: ${fs.statSync(backupPath).size} bytes`);
    
    return backupPath;
  } catch (error) {
    console.error('Error creating database backup:', error);
    const errorMessage = error instanceof Error ? error.message : String(error);
    throw new Error(`Failed to create database backup: ${errorMessage}`);
  }
}

export async function listBackups(): Promise<string[]> {
  const backupsDir = path.join(process.cwd(), 'backups');
  
  if (!fs.existsSync(backupsDir)) {
    return [];
  }

  const files = fs.readdirSync(backupsDir);
  return files
    .filter(file => file.endsWith('.sql'))
    .sort((a, b) => b.localeCompare(a)); // Sort newest first
}

export async function deleteBackup(filename: string): Promise<boolean> {
  try {
    const backupPath = path.join(process.cwd(), 'backups', filename);
    
    if (fs.existsSync(backupPath)) {
      fs.unlinkSync(backupPath);
      return true;
    }
    return false;
  } catch (error) {
    console.error('Error deleting backup:', error);
    return false;
  }
}